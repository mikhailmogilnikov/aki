<script is:inline type="module">
  (async () => {
    await new Promise((resolve, reject) => {
      const link = document.createElement("link");
      link.rel = "stylesheet";
      link.href = "/squircle.css";
      link.onload = () => resolve();
      link.onerror = () => reject(new Error("Failed to load CSS"));
      document.head.appendChild(link);
    });

    if (!("paintWorklet" in CSS)) {
      await import("/scripts/css-paint-polyfill.js");

      await new Promise((resolve) => {
        const checkPaintWorklet = () => {
          if (CSS.paintWorklet && CSS.paintWorklet.addModule) {
            resolve();
          } else {
            setTimeout(checkPaintWorklet, 50);
          }
        };
        checkPaintWorklet();
      });

      await new Promise((resolve) => setTimeout(resolve, 100));
    }

    try {
      await CSS.paintWorklet.addModule("/scripts/squircle.min.js");

      forceRepaintSquircleElements();
    } catch (error) {
      console.warn("Failed to load squircle paintWorklet:", error);

      setTimeout(async () => {
        try {
          await CSS.paintWorklet.addModule("/scripts/squircle.min.js");
          forceRepaintSquircleElements();
        } catch (retryError) {
          console.error(
            "Failed to load squircle paintWorklet on retry:",
            retryError
          );
        }
      }, 200);
    }

          function forceRepaintSquircleElements() {
        const squircleElements = document.querySelectorAll(
          ".squircle, .squircle-outline, .squircle-shadow"
        );

        if (squircleElements.length === 0) {
          // Если элементы еще не найдены, попробуем через MutationObserver
          setupSquircleObserver();
          return;
        }

        squircleElements.forEach((element) => {
          // Метод 1: Переключение классов
          const classes = Array.from(element.classList).filter(cls => 
            cls.includes('squircle')
          );
          
          classes.forEach(cls => {
            element.classList.remove(cls);
            element.offsetHeight; // Принудительный reflow
            element.classList.add(cls);
          });

          // Метод 2: Принудительное изменение CSS переменной (если используется)
          const currentRadius = getComputedStyle(element).getPropertyValue('--squircle-radius');
          if (currentRadius) {
            element.style.setProperty('--squircle-radius', currentRadius);
          }
        });
      }

      // Наблюдатель за изменениями DOM для динамически добавляемых элементов
      function setupSquircleObserver() {
        const observer = new MutationObserver((mutations) => {
          let hasSquircleElements = false;
          
          mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                if (node.matches?.('.squircle, .squircle-outline, .squircle-shadow') ||
                    node.querySelector?.('.squircle, .squircle-outline, .squircle-shadow')) {
                  hasSquircleElements = true;
                }
              }
            });
          });

          if (hasSquircleElements) {
            setTimeout(() => {
              forceRepaintSquircleElements();
            }, 50);
          }
        });

        observer.observe(document.body, {
          childList: true,
          subtree: true
        });

        // Отключаем observer через 10 секунд чтобы не тратить ресурсы
        setTimeout(() => observer.disconnect(), 10000);
      }

      // Многоуровневая стратегия для Safari
      const safariRetrySchedule = [100, 300, 500, 1000, 2000];
      
      safariRetrySchedule.forEach(delay => {
        setTimeout(forceRepaintSquircleElements, delay);
      });

      // Дополнительный fallback для полной загрузки страницы
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          setTimeout(forceRepaintSquircleElements, 50);
          setTimeout(forceRepaintSquircleElements, 200);
        });
      }
      
      window.addEventListener('load', () => {
        setTimeout(forceRepaintSquircleElements, 100);
        setTimeout(forceRepaintSquircleElements, 500);
      });

      // Последняя попытка при взаимодействии пользователя
      const userInteractionEvents = ['scroll', 'mousemove', 'touchstart', 'click'];
      let interactionAttempted = false;
      
      userInteractionEvents.forEach(event => {
        document.addEventListener(event, () => {
          if (!interactionAttempted) {
            interactionAttempted = true;
            setTimeout(forceRepaintSquircleElements, 100);
          }
        }, { once: true, passive: true });
      });
  })();
</script>
